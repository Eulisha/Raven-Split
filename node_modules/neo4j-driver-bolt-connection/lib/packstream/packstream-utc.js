"use strict";
/**
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.packDateTime = exports.unpackDateTimeWithZoneId = exports.unpackDateTimeWithZoneOffset = exports.DATE_TIME_WITH_ZONE_ID = exports.DATE_TIME_WITH_ZONE_OFFSET = void 0;
var neo4j_driver_core_1 = require("neo4j-driver-core");
var temporal_factory_1 = require("./temporal-factory");
var localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;
exports.DATE_TIME_WITH_ZONE_OFFSET = 0x49;
var DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;
exports.DATE_TIME_WITH_ZONE_ID = 0x69;
var DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;
/**
* Unpack date time with zone offset value using the given unpacker.
* @param {Unpacker} unpacker the unpacker to use.
* @param {number} structSize the retrieved struct size.
* @param {BaseBuffer} buffer the buffer to unpack from.
* @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
* @return {DateTime} the unpacked date time with zone offset value.
*/
function unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {
    unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);
    var utcSecond = unpacker.unpackInteger(buffer);
    var nano = unpacker.unpackInteger(buffer);
    var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);
    var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);
    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);
    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);
}
exports.unpackDateTimeWithZoneOffset = unpackDateTimeWithZoneOffset;
/**
 * Unpack date time with zone id value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone id value.
 */
function unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {
    unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);
    var epochSecond = unpacker.unpackInteger(buffer);
    var nano = unpacker.unpackInteger(buffer);
    var timeZoneId = unpacker.unpack(buffer);
    var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);
    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);
    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);
}
exports.unpackDateTimeWithZoneId = unpackDateTimeWithZoneId;
/*
* Pack given date time.
* @param {DateTime} value the date time value to pack.
* @param {Packer} packer the packer to use.
*/
function packDateTime(value, packer) {
    if (value.timeZoneId) {
        packDateTimeWithZoneId(value, packer);
    }
    else {
        packDateTimeWithZoneOffset(value, packer);
    }
}
exports.packDateTime = packDateTime;
/**
 * Pack given date time with zone id.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */
function packDateTimeWithZoneId(value, packer) {
    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
    var offset = value.timeZoneOffsetSeconds != null
        ? value.timeZoneOffsetSeconds
        : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);
    var utc = epochSecond.subtract(offset);
    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);
    var timeZoneId = value.timeZoneId;
    var packableStructFields = [
        packer.packable(utc),
        packer.packable(nano),
        packer.packable(timeZoneId)
    ];
    packer.packStruct(exports.DATE_TIME_WITH_ZONE_ID, packableStructFields);
}
/**
 * Pack given date time with zone offset.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */
function packDateTimeWithZoneOffset(value, packer) {
    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);
    var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);
    var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);
    var packableStructFields = [
        packer.packable(utcSecond),
        packer.packable(nano),
        packer.packable(timeZoneOffsetSeconds)
    ];
    packer.packStruct(exports.DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);
}
/**
 * Returns the offset for a given timezone id
 *
 * Javascript doesn't have support for direct getting the timezone offset from a given
 * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,
 *
 * 1. The ZoneId is applied to the timestamp, so we could make the difference between the
 * given timestamp and the new calculated one. This is the offset for the timezone
 * in the utc is equal to epoch (some time in the future or past)
 * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.
 * 3. The ZoneId is applied to the new timestamp, se we could could make the difference
 * between the new timestamp and the calculated one. This is the offset for the given timezone.
 *
 * Example:
 *    Input: 2022-3-27 1:59:59 'Europe/Berlin'
 *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00
 *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59
 *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00
 *  The offset is +1 hour.
 *
 * @param {string} timeZoneId The timezone id
 * @param {Integer} epochSecond The epoch second in the timezone id
 * @param {Integerable} nanosecond The nanoseconds in the timezone id
 * @returns The timezone offset
 */
function getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {
    var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond);
    // The wallclock form the current date time
    var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);
    var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);
    var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);
    var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);
    var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);
    var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);
    return offset;
}
function getTimeInZoneId(timeZoneId, epochSecond, nano) {
    var formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: timeZoneId,
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: false
    });
    var l = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
    var utc = Date.UTC((0, neo4j_driver_core_1.int)(l.year).toNumber(), (0, neo4j_driver_core_1.int)(l.month).toNumber() - 1, (0, neo4j_driver_core_1.int)(l.day).toNumber(), (0, neo4j_driver_core_1.int)(l.hour).toNumber(), (0, neo4j_driver_core_1.int)(l.minute).toNumber(), (0, neo4j_driver_core_1.int)(l.second).toNumber());
    var formattedUtcParts = formatter.formatToParts(utc);
    var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {
        if (currentValue.type !== 'literal') {
            obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);
        }
        return obj;
    }, {});
    var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);
    localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);
    localDateTime.hour = localDateTime.hour.modulo(24);
    return localDateTime;
}
function convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {
    if (!disableLosslessIntegers && !useBigInt) {
        return obj;
    }
    var convert = function (value) {
        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();
    };
    var clone = Object.create(Object.getPrototypeOf(obj));
    for (var prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {
            var value = obj[prop];
            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;
        }
    }
    Object.freeze(clone);
    return clone;
}
